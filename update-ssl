#!/bin/bash
set -euo pipefail

say() {
	echo -e "$(date -u -Isec): ${@}"
}

fail() {
	say "${@}" 1>&2
	exit ${EXIT_CODE:-1}
}

to_boolean() {
	case "${1,,}" in
		true | t | 1 | yes | on | enabled | enable ) echo "true" ;;
		* ) echo "false" ;;
	esac
}

is_valid_hostname() {
	local NAME="${1,,}"
	[[ "${NAME}" =~ ^([a-z0-9][-a-z0-9]*)?[a-z0-9]([.]([a-z0-9][-a-z0-9]*)?[a-z0-9])*$ ]] || return 1
	return 0
}

is_valid_port() {
	local PORT="${1}"
	[[ "${PORT}" =~ ^(0|[1-9][0-9]*)$ ]] || return 1
	[ ${PORT} -gt 0 ] || return 1
	[ ${PORT} -lt 65536 ] || return 1
	return 0
}

download_certificate() {
	local HOST="${1}"
	local SNI="${2}"
	local PORT="${3}"
	local TARGET="${4}"

	local SNI_FLAGS=()
	[ -z "${SNI}" ] || SNI_FLAGS+=(-servername "${SNI}")

	local CERT_NAME="${TARGET}/${SNI}"
	[ -z "${SNI}" ] || CERT_NAME+="@"
	CERT_NAME+="${HOST}:${PORT}.pem"
	/usr/bin/openssl s_client -connect "${HOST}:${PORT}" "${SNI_FLAGS[@]}" -showcerts </dev/null 2>/dev/null | \
		/usr/bin/openssl x509 -text > "${CERT_NAME}"
}

[ "$(id -u)" -eq 0 ] || exec /usr/bin/sudo --non-interactive --preserve-env "${0}" "${@}"

[ -v BASE_DIR ] || BASE_DIR="/app"
[ -v INIT_DIR ] || INIT_DIR="${BASE_DIR}/init"
[ -v INIT_SSL_DIR ] || INIT_SSL_DIR="${INIT_DIR}/ssl"

INSTALLED="false"

[ -v SSL_TARGET ] || SSL_TARGET="/etc/pki/ca-trust/source"

if [ -d "${INIT_SSL_DIR}" ] ; then
	REPLACE_FLAG=""
	[ -v INIT_SSL_REPLACE ] || INIT_SSL_REPLACE="false"
	"$(to_boolean "${INIT_SSL_REPLACE}")" && REPLACE_FLAG="u"

	say "Deploying the trusted certificates"

	[ -z "${REPLACE_FLAG}" ] || say "WARNING: will replace any existing files during the certificate copy"

	#
	# We use this approach b/c this will only take regular files (no symlinks!!). This
	# is important for security purposes. It will also not clobber existing files - again,
	# for security purposes.
	#
	( cd "${INIT_SSL_DIR}" && /usr/bin/find . -type f | /usr/bin/sort ) |  \
		( cd "${INIT_SSL_DIR}" && /usr/bin/cpio -p${REPLACE_FLAG}madv "${SSL_TARGET}" ) | \
		/usr/bin/sed -e 's;^;\t;g'
	INSTALLED="true"
fi

if [ -v INIT_SSL_SERVERS ] ; then
	# The INIT_SSL_SERVERS variable is a comma-separated list of coordinates
	# in the form [serverName@]serverAddressOrHostname:port, from where SSL
	# certificates should be downloaded and added to the trust store
	readarray -d "," -t SERVERS < <(echo -n "${INIT_SSL_SERVERS}")
	for SERVER in "${SERVERS[@]}" ; do
		[ -n "${SERVER}" ] || continue
		say "Downloading additional certificates from ${SERVER} ..."
		[[ "${SERVER}" =~ ^(([^@]+)@)?(([^:]+):([0-9]+))$ ]] || fail "\tInvalid certificate server spec: [${SERVER}]"
		SERVER_NAME="${BASH_REMATCH[2]}"
		HOST_NAME="${BASH_REMATCH[4]}"
		PORT="${BASH_REMATCH[5]}"
		if [ -n "${SERVER_NAME}" ] ; then
			is_valid_hostname "${SERVER_NAME}" || fail "\tInvalid server name [${SERVER_NAME}] in spec: [${SERVER}]"
		fi
		is_valid_hostname "${HOST_NAME}" || fail "\tInvalid host name [${HOST_NAME}] in spec: [${SERVER}]"
		is_valid_port "${PORT}" || fail "\tInvalid port number [${PORT}] in spec: [${SERVER}]"
		download_certificate "${HOST_NAME}" "${SERVER_NAME}" "${PORT}" "${SSL_TARGET}" || fail "\tFailed to download the certificate from [${SERVER}]"
		INSTALLED="true"
	done
fi

if ! "${INSTALLED}" ; then
	say "No certificates to be installed"
	exit 0
fi

say "Updating the trusted certificates"
/usr/bin/chown -R root:root "${SSL_TARGET}"
/usr/bin/chmod -R 0440 "${SSL_TARGET}"
exec /usr/bin/update-ca-trust extract
